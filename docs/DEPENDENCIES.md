# Dependency Management

This package uses a two-file approach for dependency management to ensure reproducible and secure installs:

## Files

- **`requirements.in`** - Human-editable file with minimal dependency specifications (lower bounds only)
- **`requirements.txt`** - Fully pinned dependencies with cryptographic hashes for reproducible installs
- **`deps.py`** - Helper script for managing dependencies
- **`deps.bat`** - Windows batch script for dependency management

## HTTP Library Dependencies

**Both `requests` and `aiohttp` are required** due to the dual sync/async architecture:

- **`requests`**: Used by synchronous wrapper methods (`*_sync`) for compatibility with existing synchronous code and integration points
- **`aiohttp`**: Used by native async methods for better performance, concurrent request handling, and modern async patterns

The [`tennis_api/adapters/http_adapter.py`](adapters/http_adapter.py) module provides a unified interface that abstracts both libraries behind a common API, isolating their usage and documenting the architectural decision.

### Why Both Libraries?

1. **Legacy Compatibility**: Existing code expects synchronous interfaces
2. **Performance**: Async operations provide better throughput for concurrent API calls
3. **Integration Points**: Some parts of the system (like Flask web interface) work better with sync operations
4. **Rate Limiting**: Async rate limiting is more efficient for managing multiple API endpoints

## Current Status

The current `requirements.txt` is **fully pinned with cryptographic hashes** generated by `pip-compile --generate-hashes`, providing:
- **Exact reproducibility**: Same dependencies across all environments
- **Security**: Hash verification prevents tampered packages
- **Predictable updates**: Controlled dependency upgrades only when explicitly updated

## Workflow

### Adding or Updating Dependencies

1. Edit `requirements.in` to add or modify dependencies
2. Try to regenerate the pinned requirements (will use upper bounds as fallback):
   ```bash
   python deps.py compile
   ```
3. Install the updated dependencies:
   ```bash
   python deps.py sync
   ```

### Installing Dependencies

For development (recommended):
```bash
python deps.py sync
```

For production (alternative):
```bash
pip install -r requirements.txt
```

### Upgrading All Dependencies

To upgrade to the latest compatible versions:
```bash
python deps.py upgrade
```

### Checking Current Versions

To see what's currently installed:
```bash
python deps.py check
```

## Windows Users

Use the batch script for convenience:
```cmd
deps.bat sync
deps.bat check
deps.bat compile
```

## Benefits

- **Predictable updates**: Upper bounds prevent breaking changes from major version bumps
- **Security**: Regular minor/patch updates still allowed for security fixes
- **Reproducible builds**: Consistent behavior across environments
- **Separation of concerns**: Human-editable .in file vs machine-generated .txt file
- **Future-ready**: Can be upgraded to fully pinned+hashed approach when needed

## Commands Reference

- `python deps.py compile` - Generate requirements.txt from requirements.in
- `python deps.py sync` - Install exact versions from requirements.txt  
- `python deps.py upgrade` - Upgrade all dependencies and recompile
- `python deps.py check` - Show current dependency versions

## Migration to Fully Pinned (Future)

When ready for fully pinned dependencies with cryptographic hashes:

1. Ensure stable network connection
2. Run `pip-compile --generate-hashes requirements.in`
3. This will replace the current upper-bound approach with exact pins + hashes

## Notes

- Never edit `requirements.txt` directly - edit `requirements.in` instead
- Always commit both `requirements.in` and `requirements.txt` to version control
- The current approach protects against breaking changes while allowing beneficial updates
- Upper bounds can be adjusted in `requirements.in` if needed (e.g., `requests>=2.31.0,<4.0.0`)